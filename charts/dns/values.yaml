# Default values for test.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

replicaCount: 1  # Unsatable to set this to more than 1 but I leave it for testing purposes.
imagePullSecrets: []
nameOverride: ""
fullNameOverride: ""

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

rbac:
  create: true
  additionalPermissions: []
  # - apiGroups: [""]
  #   resources: ["nodes"]
  #   verbs: ["list","watch"]
  # - apiGroups: [""]
  #   resources: ["pods"]
  #   verbs: ["get","watch","list"]

podAnnotations: {}

podSecurityContext: {}
  # fsGroup: 2000

service:
  # Service that points to the http port of pdns http API.
  # It is separated from the other services so the user can select service type freely from the others needed.
  http:
    enabled: true
    type: ClusterIP
    port: 80
    annotations: {}

  # Service that points to the UDP port of pdns.
  # It is separated from TCP DNS port because of limitations of Kubernetes.
  # You cannot create a service with type LoadBalancer that exposes UDP and TCP ports at the same time.
  # Two services should workaround this limitation.
  udp:
    enabled: true
    type: ClusterIP
    port: 53
    annotations: {}

  # Service that points to the TCP port of pdns.
  # It is separated from UDP DNS port because of limitations of Kubernetes.
  # You cannot create a service with type LoadBalancer that exposes UDP and TCP ports at the same time.
  # Two services should workaround this limitation.
  tcp:
    enabled: true
    type: ClusterIP
    port: 53
    annotations: {}

  # Service that points to the metrics port of externaldns.
  externalDNSMetrics:
    enabled: true
    type: ClusterIP
    port: 80
    annotations: {}

ingress:
  enabled: false
  className: ""
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  hosts:
    - host: chart-example.local
      paths:
        - path: /
          pathType: ImplementationSpecific
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

externalDNS:
  nameOverride: ""
  fullnameOverride: ""

  registry: registry.k8s.io
  repository: external-dns/external-dns
  tag: v0.13.1
  pullPolicy: IfNotPresent

  securityContext:
    runAsNonRoot: true
    runAsUser: 65534
    readOnlyRootFilesystem: true
    capabilities:
      drop: ["ALL"]

  resources:
    requests:
      cpu: 50m
      memory: 128Mi
    limits:
      cpu: 1000m
      memory: 256Mi

  sources:
    - ambassador-host
    - contour-httpproxy
    - contour-ingressroute
    - crd
    - gloo-proxy
    - ingress
    - istio-gateway
    - istio-virtualservice
    - kong-tcpingress
    - node
    - openshift-route
    - pod
    - service
    - skipper-routegroup

  logLevel: info  # panic, debug, info, warning, error, fatal
  logFormat: text  # text, json
  interval: 30s
  triggerLoopOnEvent: true
  policy: upsert-only  # sync, upsert-only.
  txtOwnerId: ""
  txtPrefix: ""
  txtWildcardReplacement: ""
  managedRecordTypes: A,CNAME,NS

pdns:
  nameOverride: ""
  fullnameOverride: ""

  registry: ghcr.io
  repository: txqueuelen/pdns-stateless
  tag: v4.4
  pullPolicy: IfNotPresent

  securityContext:
    allowPrivilegeEscalation: false
    capabilities:
      add:
      - NET_BIND_SERVICE
      drop:
      - all
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  resources:
    requests:
      cpu: 50m
      memory: 128Mi
    limits:
      cpu: 1000m
      memory: 256Mi

  apiKeySecret:
    # Specifies whether the secret should be created
    create: true
    # Annotations to add to the secret
    annotations: {}
    # The name of the secret to use.
    # If not set and create is true, a name is generated using the fullname template
    # If set and create is false, user should create the secret by himself and this is the name used.
    name: ""
    # Same as with name but for the key to look for.
    key: ""
    # The value of the secret in base64 or plain text. Base 64 takes precedence over plain value but think
    # that both of them are insecure and you should use a secret management like `helm-secrets` if you
    # want to keep this in the values of Helm instead of using your own secret management system.
    valueBase64: ""
    valuePlain: ""


  extraConfig: {}
  # lines in the pdns.conf. These are already harcoded:
  # launch: gsqlite3
  # gsqlite3-database: /data/db
  # webserver: yes
  # webserver-address: 0.0.0.0
  # webserver-port: 80
  # api: yes
  # api-key: ### from a secret above ###
  # webserver-allow-from: 0.0.0.0/0

zones: {}
# test.es: |
#   $ORIGIN .
#   test.es   300  IN SOA       ns1.test.es sysadmin.test.es 1 600 600 86400 300
#   test.es   300  IN NS	      ns1.test.es
#   test.es   300  IN NS	      ns2.test.es
#   test.es   300  IN MX	  10  mx.test.es
# test.dev: |
#   $ORIGIN .
#   test.dev   300  IN SOA      ns1.test.dev sysadmin.test.dev 1 600 600 86400 300
#   test.dev   300  IN NS	      ns1.test.dev
#   test.dev   300  IN NS	      ns2.test.dev
#   test.dev   300  IN MX	  10  mx.test.dev

shareProcessNamespace:

nodeSelector: {}

tolerations: []

affinity: {}


# find a new place to make this live:
deploymentStrategy: {}
priorityClassName: ""
dnsPolicy:
